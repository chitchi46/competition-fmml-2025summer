##<font color=E83929> ※ 諸注意

- 本講座は金融取引に対する理論的かつ実践的な学びを提供するものですが，各自で実運用する際の利益を確約するものではありません

- 配布する資料について，情報の正確性について万全を期しておりますが，その内容について保証するものではありません

- 他の受講生や運営への迷惑行為は禁止

- 受講生以外への講義資料・講義動画の共有は固く禁止します
  - 禁止事項の例
    - SNSへのアップロード
    - Githubでコードを公開

- 本講義の内容についてSNSに投稿するのはお控えください

##<font color=fbb03b> 事前準備

###<font color=fbb03b> データ準備

##<font color=fbb03b> 5.0 はじめに

###<font color=fbb03b> 5.0.1本講義の目的

Day5では，これまで学んだことを活かして，
*   これまで行った処理をまとめ，コンペに提出するコードを作成できるようになること．
*   金融のシグナル作成について，理解してもらいコンペに取り組むことができるようになっていただくこと．

を目標に簡単なシグナルを検出する戦略を作成します．

###<font color=fbb03b> 5.0.2 全体像の中における本講義の立ち位置

今回の講義では，コンペを通して特徴量探索からバックテストにあたるまでの流れを実際の戦略作成を通して学びます．<br>
また，コンペでは戦略を固定し，より良いシグナルを作成していただきます．

###<font color=fbb03b> 5.0.3 本講義の進め方

本日の講義は以下の流れで行います．
-   5.1 コンペの説明
 - 最終課題として取り組んでいただくコンペについての説明です．
-   5.2 提出用データの作成方法
 - 提出用データの作成方法について学びます．
-   5.3 サンプルサブミッションの作成
 - 簡単な戦略をもとに，サンプルサブミッションを作成します．
-  5.4 backtester
 - backtesterについて学び，作成した戦略を実際に動かしてスコアを算出し，テストを実行します．  
-  5.5 発展  
 - 具体的な戦略の改善方法を学ぶ

##<font color=fbb03b> 5.1 コンペの説明

###<font color=fbb03b> 5.1.1 背景

「金融市場取引と機械学習」の総復習として本講義を通して学んだ手法を活用し実際に収益を生み出すことを目標に取引アルゴリズムを作成していただきます.<br>

　本コンペティションへの参加は「金融市場取引と機械学習」の修了要件に含まれています.<br>
受講生のスキルレベルは各々に異なっていますが，今回こちらのコンペティションに取り組んでいただく意義はそれぞれのレベルに応じて以下のように想定されています.

- **取引アルゴリズムを作成したことがない方**：
    - 取引アルゴリズム作成の一連の流れを掴む.
    - 利益を上げられるような取引アルゴリズム作成のための試行錯誤を経験する.

- **取引アルゴリズムを作成したことがある方**：
    - 本講義の内容を踏まえて，取引アルゴリズム開発の基礎や運用成績向上のための工夫を改めて確認する.
    - 他の参加者との交流を通じて，新たな観点や知見を得る.

###<font color=fbb03b> 5.1.2 目標

より良い取引シグナルを見つけることが目標です．  
仮想通貨取引所Binanceのタイムバー形式取引データを用いて，指定した形式のシグナルを提出していただきます．  
その後，運営側で用意した注文用関数（get_orders）で，提出していただいたシグナルを用いて注文を執行します．  
そのパフォーマンスによってスコアを評価します．  

本コンペティションでは2段階の評価があります.<br>
1段階目としては提出いただいたシグナルを用いてバックテストでのシミュレーション評価を行います.<br>
2段階目としては1段階目の提出アルゴリズムの中からスコアの高かったものについて実際のフォワードテストでの運用を行い，その成績評価を行います.

1段階目のバックテストではシャープレシオ，2段階目の実運用のフォワードテストでは実現損益によって評価をします.<br>
これらの値が大きくなるような優れた取引シグナルを作成していただくことが本コンペティションの目標となります.

###<font color=fbb03b> 5.1.3 タイムライン

本コンペティションのタイムラインは以下の図のようになります.<br>
**9/5~10/10**をコンペティション期間，その後2~3週間をレビュー期間，レビュー期間の後から1ヶ月をフォワードテスト期間として設定しています.<br>
なお，フォワードテストは計算リソースの関係で以下の条件を満たしたアルゴリズムのみに対して実施されます．
1. レビュー期間評価の結果上位10位以内であること．
2. シグナルの説明用ドキュメント（後述）の運営によるレビューの結果，適切と判断されること．

###<font color=fbb03b> 5.1.4 評価指標 / 採点 / 順位

1段階目では，CPCV(第4回参考)によりデータをtrain期間とtest期間の二つに分けたバックテストによりアルゴリズムの評価を実施します.<br>
本コンペティションでは提出いただいたシグナルによる取引アルゴリズムに対してtrain期間で学習させたものをtest期間に対してバックテストを実施し評価指標としてシャープレシオを用います.<br>
なお，本コンペではリーダーボードのロバスト性を考慮し，経路数分だけ算出された評価指標の平均値をコンペのスコアとして採用しています．<br>
<br>
スコアの算出式は以下の通りです．<br>
$$ SR = ret / std $$<br>
$$ Score = \frac{\sum_{i=1}^{N}(SR_i)}{N}$$<br>
- **SR (シャープレシオ)**:
  - **ret (リターン)**: 投資対象の期待リターン．通常は一定期間の平均リターンを使用します．
  - **std (標準偏差)**: 投資対象のリターンの標準偏差．リターンの変動の度合いを示します．
- **N**: CPCVの経路数．

コンペティション期間中には1段階目のバックテスト評価による暫定の順位がリーダーボードに表示されます.(public Leaderboard)<br>
最終順位については，コンペティション終了後のレビュー期間にpublic Leaderboardにて用いたCPCVのtrain期間とtest期間の切り方とは別の切り方をしたCPCVを用いてのバックテスト評価を行います.<br>
これはpublic Leaderboardで評価に用いた経路に対してのみ高いパフォーマンスを出せるアルゴリズムは実際の運用に利用すると利益を出せない可能性があるため，未知の経路に対してのパフォーマンスを評価する必要があるためです.(private Leaderboard)<br>
コンペティション期間，レビュー期間を経てバックテスト評価の高いアルゴリズムに対して2段階目としてフォワードテストを実施します.<br>
　2段階目のフォワードテストでは研究所所有の運用モジュールを利用して仮想的にリアルタイムでの取引を実施し，その実現損益の値で評価を実施します.(実際に取引所へ注文を出すわけではなく，独自の約定ロジックにて約定の判定および損益計算を実施するものです.)<br>

###<font color=fbb03b> 5.1.5 提出形式

本コンペティションは提出されたアルゴリズムに対して運営側で指定した期間でのCPCVによって学習とバックテスト評価を行う**コード提出形式**のコンペティションです.<br>
提出形式としては以下の4つの関数を，運営が配布するBaseStrategyクラスを継承したStrategyクラスのメソッドとして実装していただく形になります.<br>

- preprocess
    - 全データ期間を一括で前処理する際に呼び出される関数．<br>各foldごとに共通の前処理を行う際に時間がかかってしまう場合はpreprocessで一括前処理をする．
    - 入力: 前処理を施す前の時間足データ
    - 出力: 前処理を施したデータ
- get_model
    - ※実装しなくても構いません．
    - 最適なパラメータ等を探索する関数
    - 入力: training期間のデータに前処理を施したデータ
    - 出力: パラメータ等が格納されたリスト等
- get_signal
    - get_modelにより得られたモデルの予測を取得する関数
    - 入力: validation期間のデータに前処理を施したデータ，get_modelにより作成されたリスト等
    - 出力: シグナルのデータ
- get_orders
    - <font color="red">**※実装の必要はありません．運営側で指定するものを使用してください．**</font>
    - 注文情報を作成する際に呼び出される関数
    - 入力: 注文時刻，ポジションの情報，preprocessやget_signalにより作成されたデータ
    - 出力: その時刻の注文情報

その他の関数については，上記4つの関数から自由に呼び出すことが可能です．<br>
そのため，コンペ提出者の皆様は実行に必要な機能を関数として自由に作成することができます．<br>
提出時には必要なライブラリのimportや, 実行に必要な関数を全て提出するコードに記述する必要があります．<br>

**また、入賞された方々には、後日Googleフォームを通じて手法の詳細を説明するドキュメントの提出をお願いする予定です。**<br>

この形式に準じていなかった場合にはスコアが-1000となるので,そのような際は提出ファイルを確認してみましょう.

　提出自体の回数は無制限です．採点タイミングは別にアナウンスします.

###<font color=fbb03b> 5.1.6 ルール

- **運営から配布されたデータ以外のデータの使用の禁止**  
　データ分析においては，EDA（Explanatory Data Analysis, 探索的データ解析の略．データを表形式やグラフ，図などを用いてわかりやすく視覚化すること．）やモデルの学習など全ての段階において外部データを使用しないでください．つまり今回のコンペティションでは，配布データ(public.pkl, public_froi.pkl, 及びそれを結合したpublic_all.pkl)のみを使用して，データ分析に取り組んでください．  

- **Hand-Labelingの禁止**  
　モデルによってではなく手作業で予測を作成することは**Hand-Labeling**と呼ばれ，ほとんどのデータ分析コンペティションでは禁止されています．今回のコンペティションでもこのルールを採用し，全てあるいは一部のテストデータに対してHand-Labelingをすることを禁止します．予測は訓練データやテストデータ以外のデータに対しても適用可能なモデルによって自動で為されるようにしてください．

-  **get_modelにおけるパラメータのハードコーディングの禁止**  
　get_model関数におけるパラメータについて，外部でチューニングしたパラメータをハードコーディングをすることは禁止させていただきます(外部データを使用した場合との判別がつかなくなるため．)．パラメータをチューニングする際には，チューニングするコードをget_modelに記述してください．

- **再現性の確保**  
　可能な限り予測の再現性を確保してください．再現性を保つためには，**乱数生成においてシード値を指定すること**が必要条件です．機械学習ライブラリscikit-learnでは，一般的に乱数生成のシード値はrandom_stateという引数やアトリビュートで指定することとされています．  
　「可能な限り」という表現がなされているのは，再現性がどうしても保てない場合が存在するためです．例えば最近では，PyTorchというディープラーニングフレームワークがバージョンアップにより全体的に精度を落とすということがありました．この場合，バージョンアップ前に作成した予測をバージョンアップ後に再現するためには，バージョンダウンする必要があります．今回のコンペティションにおいては，再現性の確保のためにそこまでする必要はありません．  

- **Private Sharingの禁止**  
　データ分析コンペティションでは一般的に，公平性の観点から個人的な情報共有は厳しく規制されています．このコンペは個人で取り組むコンペですので，他の参加者との個人的な情報共有は禁止とさせていただきます．質問をしたい場合などは参加者全員が見れるslackのチャンネルにてお願いいたします．

- **実行時間の制約**  
　Preprocess phase〜Backtest Phase完了までに**9時間**をかかる場合は自動的に採点を終了します．その場合出力画面に「SCORING TIMEOUT」と出力されます．そのため時間のかかる前処理はpreprocess関数でまとめて行うなどの工夫が望まれます．

- **将来データ参照の禁止**  
  予測時点より未来のデータを参照することを禁止します．つまり，予測時に（本来であれば参照できない）未来のデータが与えられている場合でも，予測時点までのデータが与えられた際と同じように振る舞うストラテジーを作成をしてください．

###<font color=fbb03b> 5.1.7 賞金

本コンペティションのバックテストによる評価，フォワードテストによる評価で上位に入賞された方には以下のように賞金を授与いたします．
- バックテストによる評価(private Leaderboardの上位入賞者)
    - 1位: 5万円
    - 2位: 3万円
    - 3位: 2万円
    - 4位: 1万円
    - 5位: 1万円
- フォワードテストによる評価
    - 1位: 5万円
    - 2位: 2万円
    - 3位: 1万円

###<font color=fbb03b> 5.1.8 テストについて

本コンペティションにおいて，以下の点などを確認するための手段として提出時にテストを実施しています．

- ストラテジー内において将来データを参照していないこと  
- フォワードテストに進んだ際にもストラテジーが正しく動作すること  

採点環境であるOmnicampusではテストを通過したストラテジーのみが<br>リーダーボードに掲載される仕様となっています．

Day05.ipynbにて，omnicampus上で行われるテストと同様のテストを行うことができます．<br>
必要に応じて提出前に実行していただくことにより，<br>あらかじめストラテジーがテストを通過することをご確認ください．

なお，テストを通過するために以下の点にご注意ください．  

- preprocess関数内で与えられたデータの最終行を消去しない  

これは，主にpreprocess関数内で機械学習モデルのラベルを作成してdropna関数を使用した場合などに生じます．  
フォワードテストにおいては，固定時刻ごとに一定数のデータを与えて最新の時刻に対して注文を作成する仕様になっているため，最終行を削除してしまうとフォワードテストで全く注文を出すことができなくなってしまいます．  
そのためpreprocess関数内でデータの最終行を削除するとエラーが起こるようになっております．  
機械学習モデルのラベルの作成はget_model関数内で作成してください．

<font color=fbb03b> ※注意
運営が把握できていない重大な欠陥が発見された場合，コンペルールの変更や賞金の変更はあり得ることをご了承ください

##<font color=fbb03b> 5.2 提出データの作成方法

> Add blockquote

###<font color=fbb03b> 5.2.1 提出データの概要

本コンペでは，以下のBaseStrategyクラスを継承して，シグナルを検出するStrategyクラス（提出用データ）を作成します．<br>
<font size=2>※BaseStrategyクラス及び，BaseStrategyクラス内で使用されるOrderクラス，AssetInfoクラスは，本コンペで使用されるmlbacktesterという独自のライブラリを通じてimportされています．</font>

###<font color=fbb03b> 5.2.2 各関数の概要

BaseStrategyクラスに含まれる関数は以下の通りです．但し，必ずしも全ての関数を実装する必要はありません．<br>

- preprocess
    - 全データ期間を一括で前処理する際に呼び出される関数．<br>各foldごとに共通の前処理を行う際に時間がかかってしまう場合はpreprocessで一括前処理をする．
    - 入力: 前処理を施す前の時間足データ
    - 出力: 前処理を施したデータ
- get_model
    - ※実装しなくても構いません．
    - 最適なパラメータ等を探索する関数
    - 入力: training期間のデータに前処理を施したデータ
    - 出力: パラメータ等が格納されたリスト等
- get_signal
    - get_modelにより得られたモデルの予測を取得する関数
    - 入力: validation期間のデータに前処理を施したデータ，get_modelにより作成されたリスト等
    - 出力: シグナルのデータ
- get_orders
    - <font color="red">**※実装の必要はありません．運営側で指定するものを使用してください．**</font>
    - 注文情報を作成する際に呼び出される関数
    - 入力: 注文時刻，ポジションの情報，preprocessやget_signalにより作成されたデータ
    - 出力: その時刻の注文情報

以下の図で注文作成における全体像と，各関数の役割を示します．

###<font color=fbb03b> 5.2.3 注意事項

戦略を構成する上で，以下の点にご注意ください．
- get_ordersは運営側で指定する共通の実装を行ってください．
- 上記の関数以外に関数を作成する場合（例えば一部の処理を関数化して再利用したいとき）は，その関数も合わせて提出してください．
- get_model関数で返されるmodelsは必ずバイナリ形式で保存可能な状態である必要があります．これは採点に用いるバックテスターにてget_modelで取得したmodelをpickleモジュールで保存するためです．
- get_signalの引数には，get_modelで返したmodelがそのままのデータ形式で与えられます．

##<font color=fbb03b> 5.3 サンプルサブミッションの作成

実際に提出可能なシグナルをサンプルサブミッションとして作成してみましょう．

###<font color=fbb03b> 5.3.0 そもそもシグナルとは？

シグナルは，戦略を構築するための特徴量にあたる指標です．この指標はリターンと正の相関を持っているとき有用な指標となり得ます．<br>

既存のテクニカル指標等を参考にしながら，それらを組み合わせたり統計的な処理を施したりしてより良いシグナルを作成してください．<br>
但し，シグナルにおいては解釈性を担保することが重要です．適当に組み合わせたり，解釈性を担保できない形で機械学習を利用したりしてもそれは実際の戦略では使用できません．（リサーチの過程で使用する分には問題ありません）

今回のコンペでは，シグナルに基づく実際の注文戦略が固定されていますので，その戦略に適するようなシグナルを作成してください．<br>
詳しくは "5.3.5 ④get_orders関数" を参照してください．

###<font color=fbb03b> 5.3.1 実装する戦略の概要

サンプルサブミッションで実装する戦略では，RSIという指標をシグナルとして利用します．<br>
RSI（相対力指数）は，金融市場でのトレンドの強さを評価するために使われる人気のあるテクニカル指標で，過去の一定期間の価格変動を基に，買い方優勢か売り方優勢かの状態を示します．<br>

今回実装する戦略では，get_model関数にてRSIの期間のパラメーターとして最適な長さを探し，<br>
get_signal関数で，取得したパラメーターでRSIを計算し，単純に-1から1の値に変換することでシグナルとして利用します．<br>

#### RSIの説明

RSIの具体的な計算方法は以下の通りです．<br>

$$
RS = \frac{\text{一定期間の終値の上昇幅の平均}}{\text{一定期間の終値の下落幅の平均}}
$$

$$
RSI = 100 - \left( \frac{100}{RS+1} \right)
$$

例として，7期間の終値データを用いてRSIを計算すると以下のようになります．<br>

| 時間   | 1時間目 | 2時間目 | 3時間目 | 4時間目 | 5時間目 | 6時間目 | 7時間目 |平均 |
|--------|-------|-------|-------|-------|-------|-------|-------|-------|
|  終値  | 44    | 46    | 47    | 46    | 49    | 50    | 48    | -    |
| 上昇幅 | -     | 2     | 1     | -     | 3     | 1     | -     | 1.75     |
| 下落幅 | -     | -     | -     | 1     | -     | -     | 2     | 1.5     |

- **平均上昇幅**: 1.75
- **平均下落幅**: 1.5



- **RS (相対強さ)**:
  $$
  RS = {1.75}/{1.5} \approx 1.17
  $$

- **RSI (相対力指数)**:
  $$
  RSI = 100 - ({100}/({1.17+1}))\approx 53.85
  $$
<br>
この計算例では，RSIが約54%になり，若干買い方優勢の中立的な状態であることがわかります．<br>
RSIにおいては，70％～80％を超えると買われ過ぎ，反対に20％～30％を割り込むと売られ過ぎと判断し，逆張りの目安として使われる手法も一般的ですが，今回の戦略では単純に順張りのシグナルとしてそのまま-1から1に変換します．

###<font color=fbb03b> 5.3.2 ① preprocess関数

**get_ordersで使用するため，ボラティリティを計算していますので，その部分は変更しないようにしてください．**<br>

preprocess関数では，各foldごとに共通の前処理（ex. 標準化など）を行う際に時間がかかってしまう場合に一括で前処理を行うことができます．
特に行う前処理がない場合は，特に処理を加える必要はありません．<br>

###<font color=fbb03b> 5.3.3 ② get_model関数

get_model関数では， CPCVによって分割されたtraining区間のデータをpreprocess関数で前処理したデータを利用し，最適なパラメーター等を探索します．

ここでは，RSIの期間のパラメーターについて，前日とのシグナルの差分をポジションとする戦略で簡易的に想定リターンを複数の候補で計算し，もっともリターンの大きかったパラメーターを採用しています．

###<font color=fbb03b> 5.3.4 ③ get_signal関数

get_model関数では， CPCVによって分割されたvalidation区間のデータをpreprocess関数で前処理したデータについて，get_modelで得たパラメーター等を利用してシグナルを生成します．<br>

ここでは，get_modelで得た期間のパラメーターを利用してRSIを計算し，-1から1に変換することでシグナルを生成します．

###<font color=fbb03b> 5.3.5 ④ get_orders関数 <font color=E83929> ※注意: 変更せずに使用してください

get_orders関数の目的は，最新のシグナルと市場データを基に，最適な注文（オーダー）を作成することです．<br>
以下に本コンペで使用されているget_orders関数の流れを示しています．

**1. シグナルから目標ポジションサイズを求める**<br>
get_signal関数で求めたシグナルを下の式で離散化したものを，目標ポジションサイズとします．<br>
dで表される離散化の区切りは，本コンペでは0.35としています．

$$
target\ position\ size = \text{round} \left[\frac{signal}{d}\right] \times 0.5
$$

**2. 市場リスクの計算**<br>
過去30日間の価格データから，注文時点でのボラティリティ(価格変動の度合い)を計算します．<br>
実際にはget_orders関数内では，preprocess関数で計算したものを取得する処理を行なっています．

**3. ポジションサイズの決定**<br>
求めた目標リスクと注文時のボラティリティを使い，注文金額を計算します．<br>
この式によって，目標とするポジションの大きさに，現時点での価格変動の大きさを加味した値が実際の注文後のポジションサイズとなります．

$$
position\ size = {target\ position\ size} \times \frac{0.5}{volatility}
$$

**4. シンボルごとの調整とリスクパリティ**<br>
ここまでで決定されたポジションサイズはシンボル間で大きな偏りがあるため、このままでは一枚あたりの価格が比較的大きなシンボル（今回はBTCUSDT）が結果のほとんどを決めてしまいます.<br>
一つのシンボルに偏ることによるリスクを低減させるため、<br>
a. 注文サイズをsize_ratio（シンボルごとの価格の平均値から求めた固定比）で調整したのちに、<br>
b. ボラティリティから求めたrisk_weightsによってリスクパリティ（リスク等分）を行なっています.

$$
target\ size = {position\ size} \times {size\ ratio}[symbol] \times {risk\ weights}[symbol]
$$

**4. 注文の作成**<br>
以上の計算で求めたポジションサイズと注文前のポジションサイズとの差額を，Orderクラスを利用して発注します．
所持金を超えるような注文や最低注文金額を下回るような注文は行われないことに注意してください．

では，今までに確認した数式が実際にget_orders関数内でどのように使われているかを確認してみましょう．

緑線で表されているのが注文後のポジションサイズです．<br>
黄点線の目標ポジションサイズと概形は同じですが，赤点線のボラティリティによって小さなノイズが付加されていることがわかります．
実際のget_ordersは、これに加えてシンボル毎の価格を考慮して構成されています。

**なお，シグナルコンペで使用するget_orders関数は以下で固定します．  
そのため，受講生側で変更しないようお願いいたします．**

これを行うことで，時刻ごとに注文が発注されます．<br>
Orderクラスの主な引数は以下の通りです．

- `type`: 注文のタイプ. `"MARKET"`, `"LIMIT"`, `"STOP"`, `"STOP_LIMIT"`のいずれかを指定します(必須).
- `side`: 注文の方向. `"BUY"`, `"SELL"`のいずれかを指定します(必須).
- `size`: 注文のサイズ(例：1.0). 負の場合は処理する際に絶対値に変換されます. float型で指定します(必須).
- `price`: `type`で`"LIMIT"`, `"STOP_LIMIT"`を指定した場合, 指値価格となります. `"STOP"`を指定した場合, ストップ注文のトリガー価格となります. float型で指定します(MARKET注文以外は必須).
- `symbol`: 注文を出す通貨ペア(例："BTCUSDT"). str型で指定します(必須).


注文が発注された場合，例えば以下のように表示されます．

###<font color=fbb03b> 5.3.6 提出用データの作成

<font size=4>**本講義のコンペでは以下の形式で，Strategyクラスを提出していただきます．**<br></font>
最後に，これまでに作成した①~③の3つの関数と④を，Strategyクラスとしてまとめます．<br>
提出時にはこのStrategyクラス内で使用している関数や, 必要なライブラリをimportする部分についても全て一緒に提出していただく必要があります．<br>

以下に示す Strategyクラスがsample_submissionとなります．
Strategyクラスを改良する形で，コンペに取り組んでください．

###<font color=fbb03b> 5.3.7 提出用データにおけるシグナルの可視化

##<font color=fbb03b> 5.4 バックテスターを用いた検証

本講義のコンペにおける採点は，皆様に提出していただいた関数を用いてbacktesterというモジュールでバックテストをすることで行われます．

ここではScoringというクラスを利用して，CPCV(第4回参考)によりデータをtrain期間とtest期間の二つに分けたバックテストによりアルゴリズムの評価を実施します．<br>
スコアの算出式は以下の通りです．<br>
$$ SR = ret / std $$<br>
$$ Score = \frac{\sum_{i=1}^{N}(SR_i)}{N}$$<br>
- **SR (シャープレシオ)**:
  - **ret (リターン)**: 投資対象の期待リターン．通常は一定期間の平均リターンを使用します．
  - **std (標準偏差)**: 投資対象のリターンの標準偏差．リターンの変動の度合いを示します．
- **N**: CPCVの経路数．

###<font color=fbb03b> 5.4.2 backtesterを動かしてみる

5.3で作成したStrategyをもとに，<br>
omnicampus上で行われていることを実際に行なって，スコアを算出しましょう．

まず最初にcfgの初期設定の値を設定します．<br>
この値は変更しないようにお願いいたします．

それでは，5.3で完成させたStrategyを使って，スコアを算出してみましょう．

また、今回のコンペでは外部データ(public_froi.pkl)を使用することができます。<br>
※使用する場合は raw_df=None としてください

###<font color=fbb03b> 5.4.3 テストを実行する
最後に，未来のデータを参照したりデータに不備があったりしないかのテストを行いましょう．

##<font color=fbb03b> 5.5 発展

ここでは，このシグナルをさらに良いものにする方法について考えましょう．<br>
元の戦略ではRSIを単純な順張り戦略のために利用していますが，RSIにおいては75%を上回ると買われ過ぎ，25%を下回ると売られ過ぎとして逆張り戦略のために利用することも多くあります．<br>
この事実を利用して，シグナルの絶対値が0.5を超える時に反転させてみましょう．

###<font color=fbb03b> 新しい戦略のコード

シグナルの絶対値が0.5以上になったときにシグナルの正負を反転するように書き換えました．<br>
これにより，RSIが75%以上, 25%以上になったときには，<br>
それぞれ買われすぎ, 売られすぎと判断し，逆張りの戦略を取るようなシグナルを作成することができました．<br>

実際にシグナルの様子を可視化してみるとその様子がわかります．

### スコアの計算

それでは，この新しい戦略でスコアを計算してみましょう．

今回のサンプルコードでは、全期間ではシャープレシオが0を超えておらず有効な戦略と呼ぶことはできません.<br>
他の指標を利用したり，複数の異なる区間・指標を組み合わせてトレンドを判断したり，平均を計算する期間を変更したりして，より高いスコアを得るようなシグナルを作成してください．

#<font color=fbb03b> Appendix

##<font color=fbb03b> Backtesterの詳細

### (★)`Scoring`クラス

scoring.pyはmlbacktesterからScoringクラスをインポートしてバックテストを行うためのファイルです．

`Scoring`クラスはコンフィグファイルを受け取り, バックテストを行うクラスです.

- config_fileがある場合優先, ない場合configを参照し, どちらもない場合はエラーになります.
- Strategy, raw_dfはある場合優先し, ない場合はconfigから読み込みこんだものを使用します.

### `BaseStrategy`クラス

submission以下に配置するストラテジーファイルでは, 基本的にはBaseStrategyクラスをインポートし, これを継承することにより記述します.

`BaseStrategy`クラスはトレーディング戦略の基底クラスで, 以下のメソッドを提供しています.

- `preprocess(self, raw_df: pd.DataFrame) -> pd.DataFrame`: 生データの前処理を行う
    - `preprocess`に渡されるデータは, configファイルの`ohlcv_data_path`に指定したデータを, `strategy_timeframe`にリサンプリングしたデータとなります.
    - 出力は, インデックスが2つ, 外側からtimestampインデックス(時刻), symbolインデックス(通貨ペア)を持ち, 頻度がstrategy_timeframeのデータとなります.
- `get_signal(self, preprocessed_df: pd.DataFrame, model: Any) -> pd.DataFrame`: 信号を生成
    - get_signalに渡されるデータは2つあります.
        - `preprocessed_df`: validation区間のpreprocessによる出力データとなります.
        - `models`: get_modelによる出力データとなります.
    - 出力は, `preprocess`による出力データに, `get_orders`で発注データを作る際に必要となる売買シグナルについてのカラムが追加されたデータとなります.
- `get_orders(self, latest_timestamp: pd.Timestamp, latest_bar: pd.Series, latest_signal: pd.Series, asset_info: AssetInfo) -> list[Order]`: 注文を生成
    - get_ordersに渡されるデータは4つあります.
        - `latest_timestamp`: `get_orders`が呼び出された時点でのバックテスター内部の時刻データとなります.
        - `latest_bar`: `latest_timestamp`時点での`get_signal`における出力データのレコードとなります.
        - `latest_signal`: `latest_timestamp`時点での`get_signal`における出力データのレコードとなります.
        - `asset_info`: `latest_timestamp`時点における以下の値を持つ`dataclass`となります.
    - 出力は, 発注する情報を持つOrderデータクラスオブジェクトを要素に持つリストとなります. Orderで指定する必要のある属性は以下のようになります.
- `get_model(self, train_df: pd.DataFrame) -> Any`: モデルを取得
    - `get_model`に渡されるデータは, training区間の`preprocess`による出力データとなります.
    - 出力は, `get_signal`に入力として渡すべきmodelについてのデータとなります(データの形式については自由).

#### 継承による新しい戦略の作成
`BaseStrategy`クラスを継承して新しい戦略を作成する際は, 以下の手順に従います.

1. **`BaseStrategy`クラスを継承**: 新しいクラスで`BaseStrategy`クラスを継承します.
2. **コンストラクタのオーバーライド**: 必要に応じて, コンストラクタをオーバーライドして追加の初期化を行います.
3. **メソッドのオーバーライド**: 必要なメソッド(`get_signal`, `get_orders`など)をオーバーライドして戦略をカスタマイズします.

### `Order`クラス

`Order`クラスは, `dataclass`を基にしており, 以下のフィールドを持っています.

- `type`: 注文のタイプ. `"MARKET"`, `"LIMIT"`, `"STOP"`, `"STOP_LIMIT"`のいずれかを指定します(必須).
- `side`: 注文の方向. `"BUY"`, `"SELL"`のいずれかを指定します(必須).
- `size`: 注文のサイズ(例：1.0). 負の場合は処理する際に絶対値に変換されます. float型で指定します(必須).
- `price`: `type`で`"LIMIT"`, `"STOP_LIMIT"`を指定した場合, 指値価格となります. `"STOP"`を指定した場合, ストップ注文のトリガー価格となります. float型で指定します(MARKET注文以外は必須).
- `symbol`: 注文を出す通貨ペア(例："BTCUSDT"). str型で指定します(必須).
- `minutes_to_expire`: 注文が失効するまでの時間を分単位で指定(例：60)float型で指定します(オプション).
- `exit`: reduce only注文か否か指定(例：True). bool値で指定します(オプション).
- `exit_id`: reduce only注文の場合, 決済する注文idを指定します. 注文idについては`asset_info`の`open_position`から参照できます. str型で指定します(オプション).
- `params`: その他のパラメータ. dict型で指定します(オプション).
- `message`: メッセージ. str型で指定します(オプション).

このクラスは注文情報をシステムに渡すために使用されます.

#### 例: `Order`クラスの使用方法

`Strategy`クラスの`get_orders`メソッド内で, `Order`クラスのインスタンスが生成され, リストとして返されます.

1. **LIMIT注文**: `Order`クラスを使用してLIMIT注文を作成します.
   ```python
   Order(
       "LIMIT",
       side,
       size,
       float(buy_price) if side == "BUY" else float(sell_price),
       symbol,
   )
   ```
   ここで`side`は`"BUY"`または`"SELL"`, `size`は注文のサイズ, `buy_price`または`sell_price`は注文価格, `symbol`は注文する通貨ペアです.

2. **MARKET注文**: `Order`クラスを使用してMARKET注文を作成します.
   ```python
   Order("MARKET", "SELL", size, None, symbol)
   ```
   この場合, `side`は`"SELL"`, `size`は注文のサイズです. 価格は`None`, 通貨ペアは`symbol`です.

3. **STOP注文**: `Order`クラスを使用して逆指値成行注文を作成します.
   ```python
   Order("STOP", "SELL", size, stop_sell_price, symbol)
   ```
   この場合, `side`は`"SELL"`, `size`は注文のサイズです. `stop_sell_price`はトリガー価格, `symbol`は注文する通貨ペアです.

4. **STOP_LIMIT注文**: `Order`クラスを使用して逆指値注文を作成します.
   ```python
   Order("STOP_LIMIT", "SELL", size, stop_sell_price, symbol)
   ```
   この場合, `side`は`"SELL"`, `size`は注文のサイズです. `stop_sell_price`はトリガー価格, `symbol`は注文する通貨ペアです.

#### 注文リストの生成

`get_orders`メソッドでは, 最新のシグナルと資産情報に基づいて, 注文リスト(`order_lst`)が生成されます. このリストは`Order`クラスのインスタンスで構成されています.

このようにして, `Order`クラスはトレーディング戦略において注文情報を整理・伝達するための役割を果たしています.

### `AssetInfo`クラス

`AssetInfo`クラスは, 資産に関する情報をまとめるためのクラスです. このクラスは`dataclass`を基にしており, 以下のフィールドを持っています.

- `effective_margin`: 有効証拠金 (float型). 証拠金残高から未実現損益を引いた値となります.
- `margin_balance`: 証拠金残高 (float型).
- `rpnls`: 実現損益(Realized P&L). キーが通貨ペア(str),バリューが通貨ペアの実現損益(float)となる辞書データとなります.
- `upnls`: 未実現損益(Unrealized P&L). キーが通貨ペア(str),バリューが通貨ペアの未実現損益(float)となる辞書データとなります.
- `signed_pos_sizes`: 現在のポジションサイズ. キーが通貨ペア(str),バリューが通貨ペアの保有ポジション量(float)となる辞書データとなります.
- `open_positions`: 現在開いているポジション. キーが通貨ペア(str), バリューが通貨ペアの保有しているポジションについての`OpenPosition`オブジェクトとなる辞書データとなります.
- `commissions`: 取引手数料の合計. キーが通貨ペア(str), バリューが通貨ペアの累積取引手数料の値(float)となる辞書データとなります.
- `slippages`: `MARKET`, `STOP`注文約定時のスリッページコスト. キーが通貨ペア(str), バリューが通貨ペアのスリッページコスト(float)となる辞書データとなります.
- `realized_funding_fees`: 付与・徴収された資金調達料とレバレッジ手数料の合計. キーが通貨ペア(str), バリューが通貨ペアごとに累積した資金調達料とレバレッジ手数料の値(float)となる辞書データとなります.
- `avg_prices`: 平均取引価格. キーが通貨ペア(str), バリューが通貨ペアの平均取引価格(float)となる辞書データとなります.
- `pos_sizes_in_quote`: 総ポジションサイズ(絶対値). キーが通貨ペア(str), バリューが通貨ペアのポジション量を基軸通貨(`quote_currency`)で表した値(float)となる辞書データとなります.
- `tick_sizes`: キーが通貨ペア(str), バリューが通貨ペアのtick size(float)となります.

#### 例: `AssetInfo`クラスの使用方法

`Strategy`クラスの`get_orders`メソッド内で, `AssetInfo`クラスのインスタンスが引数として渡されます. このオブジェクトを用いて, 最新の資産情報に基づいた取引戦略を組むことができます.

1. **ポジションサイズの確認**: `asset_info.signed_pos_sizes`を用いて, 通貨ペアである`symbol`の現在保有しているのポジションサイズを確認できます.
   ```python
   pos = asset_info.signed_pos_sizes[symbol]
   ```

2. **開いているポジションの処理**: `asset_info.open_positions`を用いて, 通貨ペアである`symbol`の現在開いているポジションに対する操作を行います.
   ```python
   for p in asset_info.open_positions[symbol]:
       ...
   ```

このように, `AssetInfo`クラスは現在の資産状況を反映するための重要なコンポーネントとなっています. これを用いて, 取引戦略の動的な調整が可能です.

### `latest_bar`, `latest_signal`の参照方法

`Strategy`クラスの引数である, `latest_bar`, `latest_signal`では, それぞれ, バックテスター内の時刻におけるohlcv(`backtest_timeframe`)と, その時点での最新の売買シグナルを取得できます.

#### 例: `submission_limit.py`内の`latest_bar`, `latest_signal`の参照方法

1. **`latest_bar`の参照方法**: `latest_bar`の通貨ペアと, レコードの対応関係を辞書で保存し, その値に従って`latest_bar`の値を参照する.
   ```python
   bar_idx: dict = {symbol: list(latest_bar.index.get_level_values(1)).index(symbol) for symbol in self.cfg["backtester_config"]["symbol"]}
   if p.price < latest_bar.close.values[bar_idx[symbol]] and p.size > 0:
        ...
   ```

2. **`latest_signal`の参照方法**: `latest_signal`の通貨ペアと, レコードの対応関係を辞書で保存し, その値に従って`latest_signal`の値を参照する.
   ```python
   signal_idx: dict = {symbol: list(latest_signal.index.get_level_values(1)).index(symbol) for symbol in self.cfg["backtester_config"]["symbol"]}
   if df_["order_flag"].values[signal_idx[symbol]] == 1 and pos == 0:
        ...
   ```

##<font color=fbb03b> FAQ

- Q. 採点環境にライブラリの追加依頼をすることはできますか？<br>
  - A. 可能です．Slackの#2_運営へのご意見_質問チャンネルにて，追加したいライブラリとそのバージョンをご連絡ください．<br>
追加可否の判断の上，追加していきます．<br>

- Q. Omnicampusの採点でインポートエラーがでるのですが，現在対応しているライブラリは確認できますか？<br>
  - A. このノートブックの最後に最新時点で対応しているライブラリをまとめた採点環境を記していますので，そちらをご確認ください．<br>

- Q. 実行時間の制約はありますか？<br>
  - A. はい．あります．Preprocess phase〜Backtest Phase完了までに9時間をかかる場合は自動的に採点を終了します．<br>
その場合出力画面に「SCORING TIMEOUT」と出力されます．そのため，前処理の際のパラメータ探索など<br>時間がかかる処理はあらかじめ実行し，preprocess関数では定数として与えるなどの工夫が望まれます．<br>

- Q. get_model関数の戻り値やget_signal関数の引数にある変数modelsのデータ形式について何か制約はありますか？<br>
  - A. はい，あります．get_model関数で返されるmodelは必ずバイナリ形式で保存可能な状態である必要があります．<br>
これは上記のScoringBacktestクラスにてget_modelで取得したmodelをpickleモジュールで保存するためです．<br>
またget_signalの引数には，get_modelで返したmodelsがそのままのデータ形式で与えられます．<br>

- Q. 1時刻において出せる注文は一つですか？<br>
  - A. いいえ，注文の成行注文，指値注文問わず同時に複数の注文を出せます．<br>

- Q. 採点時に返ってくるスコアの種類は何がありますが？<br>
  - A. 正常に処理された場合，評価指標のスコアを返します．何らかの実行エラーは「-1000」，ストラテジが破産した場合は「-1111」，<br>
実行時間の制約を超えた場合には，「SCORING TIMEOUT」と返します．

##<font color=fbb03b> 参考，リンクなど
[1] マルコス・ロペス・デ・プラド (著), 長尾 慎太郎 (監修, 翻訳), 鹿子木 亨紀 (監修, 翻訳), 大和アセットマネジメント (翻訳) 「ファイナンス機械学習―金融市場分析を変える機械学習アルゴリズムの理論と実践」 きんざい, 2019.

[2] [ファイナンス機械学習著者による解説スライド](https://quantresearch.org/Lectures.html)

[3] [[2]について日本語の解説記事](https://quantcollege.net/%e3%80%90%e3%83%95%e3%82%a1%e3%82%a4%e3%83%8a%e3%83%b3%e3%82%b9%e6%a9%9f%e6%a2%b0%e5%ad%a6%e7%bf%92%e3%80%91%e8%91%97%e8%80%85%e3%81%ae%e8%ac%9b%e7%be%a9%e3%82%b9%e3%83%a9%e3%82%a4%e3%83%89%e3%82%92)

##<font color=fbb03b> 著作権について

- ファイナンス機械学習(AFML)書籍中の実装コードを参考にした部分については実行セル中にスニペット番号を記載しています.

- その他実装の参考にしたurl等はセル中に記載しています.

##<font color=fbb03b> 採点環境について
採点環境で使用するPythonのバージョンとあらかじめ用意しているライブラリは以下の通りです．
```yaml
###### Public library ######`
tqdm==4.66.1
typing==3.7.4.3
wandb==0.16.1
pandas==2.1.4
seaborn==0.13.0
datetime==5.4
numpy==1.26.2
matplotlib==3.8.2
hydra-core==1.3.2
japanize-matplotlib==1.1.3
IPython==8.18.1
pytest==7.4.3
pytest-cov==4.1.0
pandas_ta==0.3.14b0
optuna==3.5.0
lightgbm==4.1.0
scikit-learn==1.3.2


## 前コンペにて要望があったもの
##（このnotebook上ではinstallしていませんが，採点環境では用意されています）
statsmodels
torch
tensorflow==2.15.0
xgboost
```

